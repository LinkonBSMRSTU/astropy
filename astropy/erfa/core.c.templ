/* Licensed under a 3-clause BSD style license - see LICENSE.rst

  "erfa.c" is auto-generated by erfa_generator.py from the template
  "erfa.c.templ". Do *not* edit erfa.c directly, instead edit the template
  and run erfa_generator.py from the source directory to update it.
*/

#include <Python.h>

#include <numpy/arrayobject.h>

#include "erfa.h"


#if PY_MAJOR_VERSION >= 3
#define PY3K 1
#else
#define PY3K 0
#endif


static const char *const module_docstring =
    "This module uses wraps the ERFA library in numpy-vectorized\n"
    "equivalents.\n"
    "\n"
    "..warning::\n"
    "    This is currently *not* part of the public Astropy API, and may change in\n"
    "    the future.\n"
    "\n"
    "Each function is passed a Numpy iterator, which is set up on the Python side in "
    "erfa/core.py.\n";


typedef struct {
    PyObject_HEAD
    NpyIter *iter;
} PyIterObject;


{%- for func in funcs %}

static PyObject *Py_{{ func.pyname }}(PyObject *self, PyObject *args, PyObject *kwds)
{
    NpyIter *iter = NULL;
    int stat_ok = 1;
    char **dataptrarray = NULL;
    NpyIter_IterNextFunc *iternext = NULL;
    int status = 1;

    {%- for arg in func.args_by_inout('in|inout|out|ret|stat') %}
    {{ arg.ctype_ptr }} _{{ arg.name }};
    {%- endfor %}

    if (!PyObject_TypeCheck(args, &NpyIter_Type)) {
        return NULL;
    }
    iter = ((PyIterObject *)args)->iter;

    iternext = NpyIter_GetIterNext(iter, NULL);
    if (iternext == NULL) {
        return NULL;
    }
    dataptrarray = NpyIter_GetDataPtrArray(iter);

    Py_BEGIN_ALLOW_THREADS

    while (status) {
        {%- for arg in func.args_by_inout('in|inout|out') %}
        _{{ arg.name }} = {%- if arg.ctype_ptr[-1] != '*' %}*{% endif %}({{ arg.ctype }} *)(dataptrarray[{{ func.args.index(arg) }}]);
        {%- endfor %}
        {{ func.args_by_inout('ret|stat')|map(attribute='name')|surround('_',' = ')|join }}{{ func.name }}({{ func.args_by_inout('in|inout|out')|map(attribute='name')|prefix('_')|join(', ') }});
        {%- for arg in func.args_by_inout('ret|stat') %}
        *(({{ arg.ctype }} *)(dataptrarray[{{ func.args.index(arg) }}])) = _{{ arg.name }};
        {%- endfor %}
        {%- for arg in func.args_by_inout('stat') %}
        if (_{{ arg.name }} != 0) {
            stat_ok = 0;
        }
        {%- endfor %}
        status = iternext(iter);
    }

    Py_END_ALLOW_THREADS

    if (stat_ok) {
        Py_RETURN_TRUE;
    } else {
        Py_RETURN_FALSE;
    }
}

{%- endfor %}

static PyMethodDef module_functions[] = {
    {%- for func in funcs %}
    { "_" "{{ func.pyname }}", (PyCFunction)Py_{{ func.pyname }}, METH_O, NULL },
    {%- endfor %}
    { NULL }
};


struct module_state
{
    int _dummy;
};

#if PY3K
static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "_core",
    NULL,
    sizeof(struct module_state),
    module_functions,
    NULL,
    NULL,
    NULL,
    NULL
};

#define INITERROR return NULL

PyMODINIT_FUNC PyInit__core(void)

#else
#define INITERROR return

PyMODINIT_FUNC init_core(void)
#endif

{
    PyObject *m;

#if PY3K
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule3("_core", module_functions, module_docstring);
#endif

    if (m == NULL) {
        INITERROR;
    }

    import_array();

#if PY3K
    return m;
#endif
}
